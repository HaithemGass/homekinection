<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>BitCloud Stack API Reference: Using the APS component</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<style>
	li > span {
		font-style:italic;
		display:block !important;
		margin-bottom:5px;
	}
	li {
		margin-bottom:5px;
	}
</style>
</head>
<body>

<div class="header">
  <div class="headertitle">
    <div class="title">Using the APS component</div>
  </div>
</div>

<div class="contents">

<p>
The application support sub-layer (APS) provides an interface between the network
layer (NWK) and the application layer (APL) through a general set of services.
The sections below describe the most common tasks performed with the use of APS.
</p>

<p></p>
<div><i>See also:</i></div>
<div><a href="globals_func.html#index_a" class="el">APS Functions</a></div>
<div><a href="aps_8h.html" class="el">APS header files</a></div>
<p></p>

<span class="table_of_contents">Contents</span>
<ul class="table_of_contents">
  <li><a href="#endpoints">Endpoint registration</a></li>
  <li>
    <a href="#data_exchange">Sending data across the network</a>
	<ul>
		<li><a href="#payload_config">Configuring a payload</a></li>
		<li><a href="#short_addressing">Using short addresses for the destination</a></li>
		<li><a href="#ext_addressing">Using extended addresses for the destination</a></li>
		<li><a href="#group_addressing">Using group addresses for the destination</a></li>
		<li><a href="#broadcast">Broadcasting</a></li>
		<li><a href="#ack">Acknowledged data transmission</a></li>
		<li><a href="#data_req_binding">Applying binding for data transmission</a></li>
		<li><a href="#sec_data_req">Data transmission in secured networks</a></li>
		<li><a href="#to_all_endpoints">Sending a message to all endpoints on destination nodes</a></li>
		<li><a href="#radius">Limiting the radius of a data frame</a></li>
	</ul>
  </li>
  <li><a href="#group_management">Managing group membership</a></li>
  <li>
    <a href="#binding">Binding management</a>
	<ul>
		<li><a href="#bind_single">Binding to a single node</a></li>
		<li><a href="#bind_group">Binding to a group</a></li>
		<li><a href="#unbind">Unbinding</a></li>
		<li><a href="#iter_binding_table">Iterating through the binding table</a></li>
	</ul>
  </li>
  <li>
    <a href="#high_sec_api">Using security keys management API</a>
	<ul>
		<li><a href="#key_mgmt_overview">Key management API overview</a></li>
		<li><a href="#set_link_key">Setting link keys</a></li>
		<li><a href="#request_link_key">Request for a link key</a></li>
		<li><a href="#master_key">Setting a master key</a></li>
	</ul>
  </li>
</ul>

<a name="endpoints"></a><span class="to_top"><a href="#">Back to top</a></span>
<h2>Endpoint registration</h2>
<p>
An endpoint is an object corresponding to a certain application object.
In ZigBee networks an endpoint is used as a source or a destination for
a data exchange. Moreover, on the application level the only way to send data 
is from one endpoint to another. To use an endpoint the application must
first register it. Endpoint registration is performed via the 
<a class="el" href="apsde_endpoint_8h.html#ad5e605753e1707e9caecb218e6cb4a7b"><code>APS_RegisterEndpointReq()</code></a> 
function.
</p>
<p>
To register an endpoint on the current device, first, define a simple
descriptor that specifies properties of the endpoint you would like to
register. The simple descriptor should be an instance of type 
<a class="el" href="struct_simple_descriptor__t.html"><code>SimpleDescriptor_t</code></a>
provided as a variable defined in a global scope. An endpoint on a given device is
identified by an endpoint ID that is a value in a range from 1 to 240.
Other parameters include the application profile ID, device type ID (within the
specified profile ID), and lists of input and output clusters. Simple
applications that are not intended to use public application profiles
can define an arbitrary value for the application profile ID, for example, 1.
If clusters are not going to be specified then <code>NULL</code> should be
passed.
</p>
<p>
To register an endpoint call the <code>APS_RegisterEndpointReq()</code> function
passing a pointer to request parameters instance of the 
<a class="el" href="struct_a_p_s___register_endpoint_req__t.html"><code>APS_RegisterEndpointReq_t</code></a>
type. Besides the simple descriptor the request parameters require a
pointer to a callback which is to be called when data destined for the
endpoint is received.
</p>
<p>
The following example illustrates the endpoint registration process:
</p>
<div class="fragment"><pre class="fragment">
<span class="comment">//Define a simple descriptor for the endpoint</span>
SimpleDescriptor_t simpleDescriptor = { APP_ENDPOINT, APP_PROFILE_ID, 1, 1, 0, 0, NULL, 0, NULL };
<span class="comment">//A variable for registering endpoint parameters</span>
APS_RegisterEndpointReq_t endpointParams;

<span class="comment">//The data indication callback to handle data reception on the endpoint</span>
<span class="keyword">void</span> APS_DataIndication(APS_DataInd_t *ind)
{
  ...
}
...
<span class="comment">//Set endpoint registration request parameters</span>
endpointParams.simpleDescriptor = &simpleDescriptor;
endpointParams.APS_DataInd = APS_DataIndication;

<span class="comment">//Register endpoint</span>
APS_RegisterEndpointReq(&endpointParams);
</pre></div>
<p>
The above code configures and registers the endpoint with the ID equal to
<code>APP_ENDPOINT</code>, the profile ID equal to <code>APP_PROFILE_ID</code>, and
with no input and output clusters specified. The function call is done
synchronously. The result of the operation is reported by the <code>status</code>
field of the request parameters.
</p>


<a name="data_exchange"></a><span class="to_top"><a href="#">Back to top</a></span>
<h2>Sending data across the network</h2>
<p>
To transmit data from the device to other network devices use the 
<a class="el" href="apsde_data_8h.html#a2a584bc786c377e3e69b0896b0d0a55f"><code>APS_DataReq()</code></a>
function. The function needs a pointer to an instance of the 
<a class="el" href="struct_a_p_s___data_req__t.html"><code>APS_DataReq_t</code></a>
type as an argument. Required request parameters include a pointer to a confirmation
callback function, information about the source and the destination, and 
the payload. There are several methods to identify the destination; for all of them
the payload configuration is done in the same way. Addressing mode is given by the
<code>dstAddrMode</code> field of the request parameters.
</p>

<a name="payload_config"></a>
<h3>Configuring a payload</h3>
<p>
The application shall allocate a continuous block of memory as a message buffer.
The buffer must include the space for the APS header, the payload, which is to
hold the actual message data, and the APS footer. The size of the APS header is 
given by the 
<a class="el" href="aps_common_8h.html#aced3428fa1b564c0995349a95d756133"><code>APS_ASDU_OFFSET</code></a>
constant. The size of the footer can
be calculated as 
<code><a class="el" href="aps_common_8h.html#a1cf798a2f6651855a2e70cdd1f727540">APS_AFFIX_LENGTH</a> - APS_ASDU_OFFSET</code>. The payload size
is arbitrary. The maximum payload size that fits one data frame depends on the 
security level used. If the actual payload size is greater than the maximum
payload size, the application should split the data into smaller pieces or use
the fragmentation feature. The message buffer can be represented by the following
structure:
</p>
<div class="fragment"><pre class="fragment">
<span class="comment">//Application message buffer structure</span>
BEGIN_PACK
<span class="keyword">typedef struct</span>
{
  uint8_t header[APS_ASDU_OFFSET]; <span class="comment">//APS header</span>
  uint8_t data[APP_ASDU_SIZE]; <span class="comment">//Application data - the payload</span>
  uint8_t footer[APS_AFFIX_LENGTH - APS_ASDU_OFFSET]; <span class="comment">// Footer</span>
} PACK AppMessageBuffer_t;
END_PACK
</pre></div>
<p>
<code>BEGIN_PACK</code>, <code>PACK</code>, and <code>END_PACK</code> macros 
are used to swith off data alignment for the structure thus making it representation
in memory continuous. <code>APP_ASDU_SIZE</code> is assumed to be an application
defined constant.
</p>
<p>
After the message buffer is defined the application can use it to specify data to
be transmitted as follows
</p>
<div class="fragment"><pre class="fragment">
AppMessageBuffer_t appMessageBuffer; <span class="comment">//A variable for the message buffer</span>
APS_DataReq_t dataReq; <span class="comment">//A variable for the request parameters</span>
...
<span class="comment">//Specify the request parameters</span>
dataReq.asdu = appMessageBuffer.data;
dataReq.asduLength = sizeof(appMessageBuffer.data);
</pre></div>
<p>
The <code>asdu</code> field of request parameters shall point to the data section of
the message buffer and the <code>asduLength</code> field shall equal its length.
</p>

<a name="short_addressing"></a>
<h3>Using short addresses for the destination</h3>
<p>
To use short addresses assign the <code>dstAddrMode</code> field in the request 
parameters to 
<a class="el" href="aps_common_8h.html#a0bc5b23d1c85adcef057f8c04dfc5365ae7b258974e64c3310ce05109e944f308"><code>APS_SHORT_ADDRESS</code></a>. 
This type of addressing can be 
used to send a unicast message to a particular node with a given short address 
or to <a href="#broadcast">send a broadcast message</a>. For a unicast message specify 
the destination short address via the <code>dstAddress.shortAddress</code> field.
</p>
<p>
Besides the addressing mode, the destination address, and the callback,
the required fields include the destination and the source endpoints, the profile
ID, and the cluster ID. The profile ID must be the same on the source and the 
destionation endpoints. The specified cluster must be supported on the source endpoint
as an output cluster and as an input cluster on the destination endpoint. The
example below shows how to send a unicast message:
</p>
<div class="fragment"><pre class="fragment">
AppMessageBuffer_t appMessageBuffer; <span class="comment">//A variable for the message buffer</span>
APS_DataReq_t dataReq; <span class="comment">//A variable for the request parameters</span>
<span class="comment">//A confirmation callback for APS_DataReq()</span>
static void APS_DataConf(APS_DataConf_t *confInfo)
{
  ...
}
...
dataReq.profileId = APP_PROFILE_ID;
dataReq.dstAddrMode = APS_SHORT_ADDRESS;
dataReq.dstAddress.shortAddress = CPU_TO_LE16(0x0001);
dataReq.dstEndpoint = DST_ENDPOINT_ID;
dataReq.clusterId = CPU_TO_LE16(SAMPLE_CLUSTER_ID);
dataReq.srcEndpoint = SRC_ENDPOINT_ID;
dataReq.radius = 0x0;
<span class="comment">//Specify a callback</span>
dataReq.APS_DataConf = APS_DataConf;
<span class="comment">//Configure the payload</span>
dataReq.asdu = appMessageBuffer.data;
dataReq.asduLength = sizeof(appMessageBuffer.data);

<span class="comment">//Issue the request</span>
APS_DataReq(&dataReq);
</pre></div>
<p>
A data is sent to the node with short address equal to 0x0001. To send a broadcast
message change the <code>dstAddress.shortAddress</code> value to a broadcast address,
for example:
</p>
<div class="fragment"><pre class="fragment">
...
dataReq.dstAddress.shortAddress = BROADCAST_ADDR_ALL;
...
</pre></div>
<p>
It is assumed in the example that there are such application-defined constants
as <code>DST_ENDPOINT_ID</code>, <code>SRC_ENDPOINT_ID</code>, <code>APP_PROFILE_ID</code>,
and <code>SAMPLE_CLUSTER_ID</code>. Note the use of <code>CPU_TO_LE16</code> macro,
which transforms a 16-bit value to a little endian value. If the value is symmetric,
like 0x000 or 0xFFFF, then the macro can be safely omitted.
</p>

<a name="ext_addressing"></a>
<h3>Using extended addresses for the destination</h3>
<p>
A destination device for data transmission can be identified with the extended address.
For this purpose, set the <code>dstAddrMode</code> field of request parameters for
<a class="el" href="apsde_data_8h.html#a2a584bc786c377e3e69b0896b0d0a55f"><code>APS_DataReq()</code></a> to 
<a class="el" href="aps_common_8h.html#a0bc5b23d1c85adcef057f8c04dfc5365a5c4534edda395953500e62e45f1b51de"><code>APS_EXT_ADDRESS</code></a>
and <code>dstAddress.extAddress</code> 
to the actual value of the extended address.
</p>
<p>
In order to transfer a data frame to the destination determined by the extended address
BitCloud still needs the short address as well. During APS data request execution the stack
searches for the short address associated with a given extended address in the address map table.
An entry containing short and extended addresses should be inserted into the address map
previously. If the entry is not found the stack calls the callback with the
<a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8a47d2ecca7d87082b977399f53e439421"><code>APS_NO_SHORT_ADDRESS_STATUS</code></a> value.
</p>
<p>
An entry is added to the address map table upon completion of a proper Device Discovery 
request, that is, a ZDP request of <code>IEEE_ADDR_CLID</code> type. See 
<a href="zdo_usage.html#zdp_device_discovery">the example</a>.
</p>

<a name="group_addressing"></a>
<h3>Using group addresses for the destination</h3>
<p>
To send a message to all members of a certain group set the <code>dstAddrMode</code> field of 
request parameters to 
<a class="el" href="aps_common_8h.html#a0bc5b23d1c85adcef057f8c04dfc5365ae7d06d84db475a76cfb47e96347c8505"><code>APS_GROUP_ADDRESS</code></a> 
and assign <code>dstAddress.groupAddress</code>
to a group address. If the destination endpoint is set to <code>0xFF</code> indication will
be raised only for endpoints that are registered with the given group address. Otherwise, an
indication will be raised on the specified endpoint, but only if it is registered with the 
received group address.
</p>
<div class="fragment"><pre class="fragment">
AppMessageBuffer_t appMessageBuffer; <span class="comment">//A variable for the message buffer</span>
APS_DataReq_t dataReq; <span class="comment">//A variable for the request parameters</span>
<span class="comment">//A confirmation callback for APS_DataReq()</span>
void APS_DataConf(APS_DataConf_t *confInfo)
{
  ...
}
...
dataReq.profileId = APP_PROFILE_ID;
dataReq.srcEndpoint = SRC_ENDPOINT_ID;
dataReq.dstAddrMode = APS_GROUP_ADDRESS;
dataReq.dstAddress.groupAddress = CPU_TO_LE16(0x0001);
dataReq.dstEndpoint = DST_ENDPOINT_ID;
dataReq.clusterId = CPU_TO_LE16(SAMPLE_CLUSTER_ID);

dataReq.radius = 0x0;
<span class="comment">//Specify a callback</span>
dataReq.APS_DataConf = APS_DataConf;
<span class="comment">//Configure the payload</span>
dataReq.asdu = appMessageBuffer.data;
dataReq.asduLength = sizeof(appMessageBuffer.data);

<span class="comment">//Issue the request</span>
APS_DataReq(&dataReq);
</pre></div>
<p>
It is assumed in the example that there are such application-defined constants
as <code>DST_ENDPOINT_ID</code>, <code>SRC_ENDPOINT_ID</code>, <code>APP_PROFILE_ID</code>,
and <code>SAMPLE_CLUSTER_ID</code>. The data is sent to all members of the group
with the group address equal to 1. Note the use of <code>CPU_TO_LE16</code> macro,
which transforms a 16-bit value to a little endian value. If the value is symmetric,
like 0x000 or 0xFFFF, then the macro can be safely omitted.
</p>
<p>
To find out how to add a device to a group see <a href="#group_management">Managing group membership</a>.
</p>


<a name="broadcast"></a>
<h3>Broadcasting</h3>
<p>
To send a message to all nodes in the network or to all routers the 
application shall use broadcasting. For broadcasting in 
<a class="el" href="apsde_data_8h.html#a2a584bc786c377e3e69b0896b0d0a55f"><code>APS_DataReq()</code></a>
parameters specify <a href="#short_addressing">the short addressing</a> as the 
addressing mode and assign the <code>dstAddress.shortAddress</code> field to one 
of broadcast addresses:
</p>
<ul>
  <li>
    <span>BROADCAST_ADDR_ALL (0xFFFF)</span>
	<div>Send the message to all nodes in the network</div>
  </li>
  <li>
    <span>BROADCAST_ADDR_RX_ON_WHEN_IDLE (0xFFFD)</span>
	<div>Send the message to all nodes with rxOnWhenIdle set to 1</div>
  </li>
  <li>
    <span>BROADCAST_ADDR_ROUTERS (0xFFFC)</span>
	<div>Send the message to all routers</div>
  </li>
</ul>
<p>
Other request parameters shall be configured in the same way as for a unicast message.
</p>

<a name="ack"></a>
<h3>Acknowledged data transmission</h3>
<p>
While sending a unicast data message it is possible to request for
acknowledgement on the application level by setting the <code>txOptions.acknowledgedTransmission</code>
field of the APS data request parameters to 1:
<div class="fragment"><pre class="fragment">
<a class="el" href="struct_a_p_s___data_req__t.html">APS_DataReq_t</a> dataReq; <span class="comment">//A variable for the request parameters</span>
...
dataReq.txOptions.acknowledgedTransmission = 1;
</pre></div>
<p>
In this cases execution of a confirmation callback with 
<a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8a0787d3e34ec427cb7d3107395f348538"><code>APS_SUCCESS_STATUS</code></a> 
means 
that the data has been successufully delivered and the indication callback has been
called on the destination endpoint. If an acknowledgement is not requested then the
confirmation callback is called after the response from a node in one hop distance is 
received by the stack, thus calling the callback does not imply that the message has
been delivered.
</p>


<a name="data_req_binding"></a>
<h3>Applying binding for data transmission</h3>
<p>
To send data to all devices bound to a given cluster on the local device use 
<a class="el" href="apsde_data_8h.html#a2a584bc786c377e3e69b0896b0d0a55f"><code>APS_DataReq()</code></a>
with the <code>dstAddrMode</code> field of the request
parameters set to 
<a class="el" href="aps_common_8h.html#a0bc5b23d1c85adcef057f8c04dfc5365a0d86b2a778d6ff80a43cb246fe4732c2"><code>APS_NO_ADDRESS</code></a>. 
In this case the <code>dstAddress</code>
field is not used. Information about destination devices is obtained from the
binding table, i.e. the message is sent to all extended addresses that occur in 
the binding table paired with the specified cluster ID. Consider the example:
</p>
<div class="fragment"><pre class="fragment">
AppMessageBuffer_t appMessageBuffer; <span class="comment">//A variable for the message buffer</span>
APS_DataReq_t dataReq; <span class="comment">//A variable for the request parameters</span>
<span class="comment">//A confirmation callback for APS_DataReq()</span>
void APS_DataConf(APS_DataConf_t *confInfo)
{
  ...
}
...
dataReq.profileId = APP_PROFILE_ID;
dataReq.srcEndpoint = SRC_ENDPOINT_ID;
dataReq.dstAddrMode = APS_NO_ADDRESS;
dataReq.clusterId = CPU_TO_LE16(SAMPLE_CLUSTER_ID);

dataReq.radius = 0x0;
<span class="comment">//Specify a callback</span>
dataReq.APS_DataConf = APS_DataConf;
<span class="comment">//Configure the payload</span>
dataReq.asdu = appMessageBuffer.data;
dataReq.asduLength = sizeof(appMessageBuffer.data);

<span class="comment">//Issue the request</span>
APS_DataReq(&dataReq);
</pre></div>
<p>
It is assumed in the example that there are such application-defined constants
as <code>SRC_ENDPOINT_ID</code>, <code>APP_PROFILE_ID</code>,
and <code>SAMPLE_CLUSTER_ID</code>. Note the use of <code>CPU_TO_LE16</code> macro,
which transforms a 16-bit value to a little endian value. If the value is symmetric,
like 0x000 or 0xFFFF, then the macro can be safely omitted.
</p>
<p>
To find out how to bind to a device or to a group see 
<a href="#binding">Binding management</a>.
</p>

<a name="sec_data_req"></a>
<h3>Data transmission in secured networks</h3>
<p>
Generally, if the standard security mode is enabled and the device has 
joined a secured network, then encryption of data frames is performed 
automatically by the stack. Thus sending APS data request is the same as 
for unsecured networks.
</p>
<p>
However, applying the high security mode requires some additional coding.
Each pair of communicating nodes in a network employing the high security mode
must possess a link key associated for this pair. If a link key is unknown it
can be requested from the trust center with the use of the 
<a class="el" href="apsme_request_key_8h.html#a8c5b6259fe787815cd4317c41570a655"><code>APS_RequestKeyReq()</code></a>
function. The trust center sends a message containing the link key to both 
the originator of the request and the destination node. Find out 
<a href="#request_link_key">more details</a> on requesting link key as well as 
source code examples.
</p>
<p>
The high security mode offers two levels of encryption. Encryption on
the network layer is performed with the use of the network key and is
similar to the standard security mode. In the high security mode, 
additional encryption with a link key occurs for the APS payload. This option 
is enabled or disabled in request parameters of 
<a class="el" href="apsde_data_8h.html#a2a584bc786c377e3e69b0896b0d0a55f"><code>APS_DataReq()</code></a>
by setting the <code>txOptions.securityEnabledTransmission</code> field to 1 or 0, 
respectively. 
</p>
<div class="fragment"><pre class="fragment">
APS_DataReq_t dataReq; <span class="comment">//A variable in the global scope</span>
...
<span class="keyword">#ifdef</span> _HIGH_SECURITY_
  <span class="comment">//Compiled for the high security mode only</span>
  <span class="comment">//Enable encryption on the APS level</span>
  dataReq.txOptions.securityEnabledTransmission = 1;
<span class="keyword">#endif</span> //_HIGH_SECURITY_
</pre></div>
<p>
Another parameter, <code>txOptions.useNwkKey</code>, being set
to 1 turns off the NWK encryption while forcing the APS encryption to use
the network key instead of the link key. Note that if the first parameter
is set to 0 and the second to 1, then the frame is sent without encryption. 
Consider a code sample:
</p>
<div class="fragment"><pre class="fragment">
APS_DataReq_t dataReq; <span class="comment">//A variable in the global scope</span>
...
<span class="comment">//Disable encryption on the APS level</span>
dataReq.txOptions.securityEnabledTransmission = 0;
<span class="comment">//Disable encryption on the NWK level and force using the network key on the APS</span> 
<span class="comment">//level, but since APS encryption is disabled the frame will be sent unencrypted</span>
dataReq.txOptions.useNwkKey = 1;
...
APS_DataReq(&dataReq);
</pre></div>

<a name="to_all_endpoints"></a>
<h3>Sending a message to all endpoints on destination nodes</h3>
<p>
To deliver message to all endpoints registered on destination nodes the
<a class="el" href="struct_a_p_s___data_req__t.html#a735d3b4ba36dc998fa64f77bb21c3949"><code>dstEndpoint</code></a>
field of the request parameters shall be set to <code>0xFF</code>.
For each registered endpoint on a destination node an indication callback 
will be called. If group addressing is used then the message will be
delivered only to those endpoints that are registered with the specified
group address on a destination node.
</p>

<a name="radius"></a>
<h3>Limiting the radius of a data frame</h3>
<p>
The <code>radius</code> field of the APS data request parameters limits a
maximum distance in hops at which the destination should be located. Each 
message retransmission on its route to the destination decreases the radius by
1. When the radius reaches 0, the frame is dropped. Setting the <code>radius</code> field
in the request parameters to 0 allows transmitting data over any distances.
</p>

<a name="group_management"></a><span class="to_top"><a href="#">Back to top</a></span>
<h2>Managing group membership</h2>
<p>
A node can add itself to an arbitrary group with the help of the
<a class="el" href="apsme_group_8h.html#a64bb9bf327968a882d9c81f0cbc67f5a"><code>APS_AddGroupReq()</code></a> 
function. A group is identified with a 16-bit
group address which has to be specified in the add group request parameters
as well as an endpoint. Calling the function causes an insertion of a new entry
into the group table. The function can be called several times with the
same group address and different endpoints. Consider a simple example, in
which the device is added to a group with the address equal to <code>0x0001</code>
and associated with the endpoint 1:
</p>
<div class="fragment"><pre class="fragment">
APS_AddGroupReq_t addGroupReq; <span class="comment">//Request parameters variable need not to be global</span>
                               <span class="comment">//since the function call is synchronous</span>
addGroupReq.endpoint = 1;
addGroupReq.groupAddress = 0x0001;
APS_AddGroupReq(&addGroupReq);

<span class="comment">//Check that the request is executed successfully</span>
if (APS_SUCCESS_STATUS == addGroupReq.confirm.status)
{
  ...
} 
<span class="comment">//Otherwise, check whether the table if full</span>
else if (APS_TABLE_FULL_STATUS == addGroupReq.confirm.status)
{
  ...
}
</pre></div>
<p>
Removing from a group is done with the help of the 
<a class="el" href="apsme_group_8h.html#a1817dc1d30b3634608cbab0b14c4819c"><code>APS_RemoveGroupReq()</code></a>
function. Request parameters are configured in the same way as for 
the add group request. Setting the <code>endpoint</code> field to 
<code>0xFF</code> will cause deletion of all group table entries 
with the specified group address. There is also a convenient 
<a class="el" href="apsme_group_8h.html#abffb03739264507fe711c79c38a2cb43"><code>APS_RemoveAllGroupsReq()</code></a>
function which removes the device 
from all groups associated with the given endpoint or from all groups at all
if the <code>0xFF</code> value is specified for the endpoint.
</p>

<a name="binding"></a><span class="to_top"><a href="#">Back to top</a></span>
<h2>Binding management</h2>
<p>
Binding n endpoint on the current device to a specific endpoint on a remote node 
requires the extended address of that node. If the extended address of the remote 
device is unknown, but the short address is given, the extended address can be 
obtained with the use of <a href="zdo_usage.html#zdp_device_discovery">Device discovery</a>, 
which employs a dedicated ZDP request. If the short address is also unknown to the application, 
it can perform a <a href="zdo_usage.html#zdp_service_discovery">Service Discovery</a>
procedure to obtain short addresses of devices that support a specific cluster.
</p>
<p>
Binding to a remote device is performed via the 
<a class="el" href="apsme_bind_8h.html#a00f4be3114dfcee6e2a6409b19adf6fb"><code>APS_BindReq()</code></a>
function.
The function requires a pointer to an instance of the 
<a class="el" href="struct_a_p_s___bind_req__t.html"><code>APS_BindReq_t</code></a> type.
A function call is done synchronously since the the function just inserts a new entry
into the binding table. In the request parameters specify the source and the destination
extended addresses and endpoints as well as the cluster to be associated with this binding
link.
</p>

<a name="bind_single"></a>
<h3>Binding to a single node</h3>
<p>
The following example illustrates the process of binding to a single node:
</p>
<div class="fragment"><pre class="fragment">
APS_BindReq_t bindReq; <span class="comment">//A variable for binding request parameters</span>
                          <span class="comment">//need not to be global</span>
CS_ReadParameter(CS_UID_ID, &bindReq.srcAddr); <span class="comment">//Read own extended address</span>
bindReq.srcEndpoint = APP_ENDPOINT; <span class="comment">//Assign to application-defined constant</span>
bindReq.clusterId = APP_CLUSTER; <span class="comment">//Assign to application-defined constant</span>
bindReq.dstAddrMode = APS_EXT_ADDRESS;
bindReq.dst.unicast.extAddr = dstExtAddr; <span class="comment">//Assign to the extended address of the</span>
                                         <span class="comment">//destination node</span>
bindReq.dst.unicast.endpoint = dstEndpoint; <span class="comment">//Assign to the destination endpoint</span>
APS_BindReq(&bindReq); <span class="comment">//Synchronous call to APS</span>

<span class="comment">//Check that the request is executed successfully</span>
if (APS_SUCCESS_STATUS == bindReq.confirm.status)
{
  ...
} 
</pre></div>
<p>
To obtain the extended address of the node ob which the application runs
read the value of the 
<a class="el" href="cs_defaults_8h.html#a330d543f324150e27474f40c950333c2"><code>CS_UID</code></a> 
parameter. The cluster with the
<code>APP_CLUSTER</code> ID has to be supported as an output cluster on the
source endpoint and as an input cluster on the destination endpoint.
</p>

<a name="bind_group"></a>
<h3>Binding to a group</h3>
<p>
It is also possible to bind an endpoint on the current device to an
entire group. The following example illustrates the process of binding to a group:
</p>
<div class="fragment"><pre class="fragment">
APS_BindReq_t bindReq; <span class="comment">//A variable for binding request parameters</span>
                      <span class="comment">//need not to be global</span>
CS_ReadParameter(CS_UID_ID, &bindReq.srcAddr); <span class="comment">//Read own extended address</span>
bindReq.srcEndpoint = APP_ENDPOINT; <span class="comment">//Assign to application-defined constant</span>
bindReq.clusterId = APP_CLUSTER; <span class="comment">//Assign to application-defined constant</span>
bindReq.dstAddrMode = APS_GROUP_ADDRESS;
bindReq.dst.group = groupAddr; /<span class="comment">/set to the address of the group (16bit value)</span>
APS_BindReq(&bindReq); <span class="comment">//Synchronous call to APS</span>
<span class="comment">//Check the execution status here</span>
...
</pre></div>
<p>
In this case if data is sent using binding and the <code>APP_CLUSTER</code> cluster,
the data is delivered to group members. Indication is raised on those endpoints only 
that are registered with the group address and support <code>APP_CLUSTER</code> as an input
cluster.
</p>

<a name="unbind"></a>
<h3>Unbinding</h3>
<p>
Unbinding from a group or a device is performed via the 
<a class="el" href="apsme_bind_8h.html#ab418bf268ff652a18f4a2c0c89a18504"><code>APS_UnbindReq()</code></a>
function supplied with a pointer to <code>APS_UnbindReq_t</code>
type which is actually the same type as 
<a class="el" href="struct_a_p_s___bind_req__t.html"><code>APS_BindReq_t</code></a>. 
This implies that to unbind froma a group or a device you shall configure 
request parameters exactly the same way as for binding, for example:
</p>
<div class="fragment"><pre class="fragment">
APS_UnbindReq_t unbindReq; <span class="comment">//A variable for unbinding request parameters</span>
                        <span class="comment">//need not to be global</span>
CS_ReadParameter(CS_UID_ID, &unbindReq.srcAddr); <span class="comment">//Read own extended address</span>
unbindReq.srcEndpoint = APP_ENDPOINT; <span class="comment">//Assign to application-defined constant</span>
unbindReq.clusterId = APP_CLUSTER; <span class="comment">//Assign to application-defined constant</span>
unbindReq.dstAddrMode = APS_EXT_ADDRESS;
unbindReq.dst.unicast.extAddr = dstExtAddr; <span class="comment">//Assign to the extended address of the</span>
                                         <span class="comment">//destination node</span>
unbindReq.dst.unicast.endpoint = dstEndpoint; <span class="comment">//Assign to the destination endpoint</span>
APS_UnbindReq(&unbindReq); <span class="comment">//Synchronous call to APS</span>
<span class="comment">//Check the execution status here</span>
...
</pre></div>

<p>
Binding simplifies configuring parameters for data transferring. See the example of 
<a href="#data_req_binding">sending data with the help of binding</a>.
</p>

<a name="iter_binding_table"></a>
<h3>Iterating through the binding table</h3>
<p>
Although BitCloud does not provide separate API for obtaining the contents 
of the binding table, the applicaiton can accomplish this task using the
<a class="el" href="config_server_8h.html#abef924ef7ebd06fb5fc4d69cd32c5b81"><code>CS_GetMemory()</code></a> 
function to obtain the pointer to the binding table.
An entry inside the binding table is of the 
<a class="el" href="struct_a_p_s___bind_req__t.html"><code>APS_BindReq_t</code></a> 
type, which is the type for 
<a class="el" href="apsme_bind_8h.html#a00f4be3114dfcee6e2a6409b19adf6fb"><code>APS_BindReq()</code></a> 
as well. It is also possible to use the 
<code>ApsBindingEntry_t</code> type which is actually a typedef for <code>APS_BindReq_t</code>. 
Therefore a pointer value received with <code>CS_GetMemory()</code> should be casted to
<code>APS_BindReq_t</code>, then to iterate through the table the user only has to
increment the pointer. The user must not change the contents of the memory which is
accessed with the use of <code>CS_GetMemory()</code>. For this purpose there is 
always an appropriate API in BitCloud. For example, in case of binding an entry is
inserted into the table by <code>APD_BindReq()</code> and removed by 
<code>APS_UnbindReq()</code> described above. The user must also ensure that the 
pointer does not get out of the table memory. For this purpose the size of the table \
shall be obtained and used.
</p>
<p>
The following example illustrates the described steps:
</p>
<div class="fragment"><pre class="fragment">
<span class="comment">//a variable to hold the pointer to the binding table memory</span>
APS_BindReq_t* bindingEntry;
<span class="comment">//a variable to keep the binding table size</span>
uint8_t bindingTableSize;

<span class="comment">//Obtain a pointer to the binding table memory</span>
CS_GetMemory(<a class="el" href="">CS_APS_BINDING_TABLE_ID</a>, (void *)&bindingEntry);
<span class="comment">//Read the size of the binding table</span>
CS_ReadParameter(<a class="el" href="">CS_APS_BINDING_TABLE_SIZE_ID</a>, (void *)&bindingTableSize);

APS_BindReq_t* iter = bindingEntry;
<span class="keyword">const</span> ApsBindingEntry_t *<span class="keyword">const</span> end = iter + bindingTableSize;

<span class="comment">//Iterate through the table contents</span>
<span class="keyword">for</span> (; iter < end; ++iter)
{
  <span class="comment">//Process required actions for each entry with the extended address</span>
  <span class="comment">//equal to destAddressOfInterest</span>
  <span class="keyword">if</span> (APS_EXT_ADDRESS == iter->dstAddrMode)
    <span class="keyword">if</span> (destAddressOfInterest == iter->dst.unicast.extAddr)
      <span class="comment">//Process an entry</span>
      ...
}
</pre></div>


<a name="high_sec_api"></a><span class="to_top"><a href="#">Back to top</a></span>
<h2>Using security keys management API</h2>

<a name="key_mgmt_overview"></a>
<h3>Key management API overview</h3>
<p>
Security keys are used for encrypting data frames and device authentication in secured 
networks. In addition to no security mode, when no encryption and np keys are used, there
are two more security modes in BitCloud networks: standard security and high security.
In standard secrurity network operation involves one type of keys called the netwok key.
While when the high security mode is applied the network operates with the network key,
link keys and, optionally, master keys.
</p>
<p>
The API supporting key management is provided by the APS component and is spread in
several header files. This brief overview is intended to bring together all functions
related to security key management. All of these functions can be used by the trust center
node only. Nodes different from the trust center has access to a limited number of
functions.
</p>
<p>
The network key is handled almost entirely by the stack. Although a typical network
uses a single network key for all network communications, a device in such a network can
store more than several network keys at a time with one key being active. The trust
center can switch the current active key to another key on a remote device via the
<a class="el" href="apsme_switch_key_8h.html#a1bb21d70018271538c85d9859b8ee5b6"><code>APS_SwitchKey()</code></a> function.
Another function, 
<a class="el" href="apsme_transport_key_8h.html#ab972779dde4fd36ece73ae3e5f07ff10"><code>APS_TransportKey()</code></a>, 
is mostly used by the APS component though the application can also use it to transfer
a key (not only the network key) over the air. These are all major functions for the 
stadard security mode.
</p>
<p>
Within high security much more rich API is available. Consider the following list of 
functions providing basic function descriptions; for detail click a link to see function
documentation:
</p>
<ul>
  <li>
    <span>
	  <a class="el" href="aps_crypto_keys_8h.html#af6bad000710b8a34e6493005132fe288"><code>APS_SetMasterKey()</code></a> and
	  <a class="el" href="aps_crypto_keys_8h.html#a4d97ec9bad11b340c8fa114db1d7a92c"><code>APS_SetLinkKey()</code></a>
	</span>
	<div>The functions set a master key and a link key for a given device. The value is written
	to an internal structure.</div>
  </li>
  <li>
    <span>
	  <a class="el" href="aps_crypto_keys_8h.html#a7d48f855d7bdc744b7f3bc5e5e9d57e4"><code>APS_GetMasterKey()</code></a> and
	  <a class="el" href="aps_crypto_keys_8h.html#af284854b8e67a19aa3ecdab2271b0705"><code>APS_GetLinkKey()</code></a>
	</span>
	<div>The functions get a master key and a link key values for a given device. The value is read
	from an internal structure.</div>
  </li>
  <li>
    <span>
	  <a class="el" href="aps_crypto_keys_8h.html#a3229d2abe9efd3d4e35cd4338cfaf988"><code>APS_FindKeys()</code></a>
	</span>
	<div>The function performs search of set master or link keys stored by the stack.</div>
  </li>
  <li>
    <span>
	  <a class="el" href="apsme_request_key_8h.html#a8c5b6259fe787815cd4317c41570a655"><code>APS_RequestKeyReq()</code></a>
	</span>
	<div>The function sends a command to the trust center to establish a link key for communication
	with a particular device.</div>
  </li>
</ul>

<a name="set_link_key"></a>
<h3>Setting link keys</h3>
<p>
Before the network start in high security mode a device should set
link keys using the 
<a class="el" href="aps_crypto_keys_8h.html#a4d97ec9bad11b340c8fa114db1d7a92c"><code>APS_SetLinkKey()</code></a> 
function. Each device except for the trust center should specify a link 
key for communication with the trust center if 
<a class="el" href="cs_defaults_8h.html#a90c571c9ce64320c8418ad0ee9b71142"><code>CS_ZDO_SECURITY_STATUS</code></a> 
equals 1 and <a href="#master_key">a master key</a> if <code>CS_ZDO_SECURITY_STATUS</code> equals 2.
</p>
<p>
It is reasonable to embrace the code for the high security mode with the
conditional defines checking if <code>_HIGH_SECURITY_</code> is enabled.
In the following example the coordinator is to act as the trust center.
Besides the coordinator, two more devices with <code>DEVICE1_EXT_ADDR</code> 
and <code>DEVICE1_EXT_ADDR</code> extended addresses are to join the network.
</p>
<div class="fragment"><pre class="fragment">
<span class="keyword">#define</span> LINK_KEY {0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa}
DeviceType_t deviceType;
//deviceType is initialized somewhere in the code
...
<span class="comment">//The following code is compiled for applications with</span>
<span class="comment">//high security only</span>
<span class="keyword">#ifdef</span> _HIGH_SECURITY_
  <span class="keyword">if</span> (deviceType != DEVICE_TYPE_COORDINATOR)
  {
    uint8_t linkKey[16] = LINK_KEY;
    ExtAddr_t extAddr = CCPU_TO_LE64(COORDINATOR_EXT_ADDR);
    APS_SetLinkKey(&extAddr, linkKey);
  }
  <span class="keyword">else</span>
  {
    uint8_t linkKey[16] = LINK_KEY; <span class="comment">//Link key is the same for both</span>
                                    <span class="comment">//devices</span>
    
    <span class="comment">//Extended address for the first device</span>
    ExtAddr_t extAddr = CCPU_TO_LE64(DEVICE1_EXT_ADDR);
    APS_SetLinkKey(&extAddr, linkKey);

    <span class="comment">//Extended address for the second device</span>
    ExtAddr_t extAddr1 = CCPU_TO_LE64(DEVICE2_EXT_ADDR);
    APS_SetLinkKey(&extAddr1, linkKey);
  }
<span class="keyword">#endif</span> // _HIGH_SECURITY_
</pre></div>
<p>
<code>devicetype</code> is a variable holding the device type. The way its
value is determined depends on ht eapplication entirely. The application
may choose to built different firmware images for every device type or
specify the device type at runtime. The <code>CCPU_TO_LE64</code> macro 
converts a 64-bit value to a 64-bit little endian value.
</p>

<a name="request_link_key"></a>
<h3>Request for a link key</h3>
<p>
If a node does not know a link key for communication with a remote node it should
send a request for it to the trust center via the 
<a class="el" href=""><code>APS_RequestKeyReq()</code></a>.
function. To find out whether a link key for a certain node is known, i.e. is
stored in the APS key-pair set, use the 
<a class="el" href=""><code>APS_FindKeys()</code></a> as 
follows:
</p>
<div class="fragment"><pre class="fragment">
<span class="comment">//A variable to keep the extended address of a device with which</span>
<span class="comment">//the application is going to communicate with</span>
ExtAddr_t extAddrToCommunicateWith;
...
<span class="keyword">if</span> (!APS_KEYS_FOUND(APS_FindKeys(&extAddrToCommunicateWith)))
{
  <span class="comment">//Link key is not found</span>
  ...
}
</pre></div>
<p>
If a link key is not found in order to send data to the node the application shall
request for a link key. The example illustrates parameters configuration for the
<code>APS_RequestKeyReq()</code> function.
</p>
<div class="fragment"><pre class="fragment">
ExtAddr_t tcAddr;
<span class="comment">//Read the trust center address and store it in a prepared variable</span>
CS_ReadParameter(CS_APS_TRUST_CENTER_ADDRESS_ID, &tcAddr);

apsRequestKeyReq.destAddress = tcAddr;
apsRequestKeyReq.keyType = APS_APP_KEY_TYPE;
apsRequestKeyReq.partnerAddress = extAddrToCommunicateWith;
apsRequestKeyReq.APS_RequestKeyConf = apsRequestKeyConf; <span class="comment">//Confirmation callback</span>
 
APS_RequestKeyReq(&apsRequestKeyReq);
</pre></div>


<a name="master_key"></a>
<h3>Setting a master key</h3>
<p>
A master key is used to authenticate a device joining a network on the 
trust center. This situation occurs in networks with the high security mode
enabled and the 
<a class="el" href="cs_defaults_8h.html#a90c571c9ce64320c8418ad0ee9b71142"><code>CS_ZDO_SECURITY_STATUS</code></a> 
equal to 2. In this case the trust center must be aware of master keys 
for all devices that are going to join the network.
</p>
<p>
A master key should be set on the joining device as well as on the trust center 
using the
<a class="el" href="aps_crypto_keys_8h.html#af6bad000710b8a34e6493005132fe288"><code>APS_SetMasterKey()</code></a> 
function, which inserts an entry into the APS key-pair set containing a specified master key
and the destination extended address (for the joining device it will be 
the trust center address, for the trust center - the joining device's address).
</p>

</div>
<img src="footer.png" style="margin-top:20px"/>
</body>
</html>
